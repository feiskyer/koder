#!/usr/bin/env python3
"""Generate bundled Codex prompt module from upstream releases.

This script fetches prompt files from the openai/codex repo and writes a
Python module with embedded prompt strings for offline/runtime use.
"""

from __future__ import annotations

import argparse
import json
import re
import urllib.error
import urllib.request
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Tuple

CODEX_GITHUB_API_RELEASES = "https://api.github.com/repos/openai/codex/releases/latest"
CODEX_GITHUB_HTML_RELEASES = "https://github.com/openai/codex/releases/latest"
RAW_URL_TEMPLATE = (
    "https://raw.githubusercontent.com/openai/codex/{tag}/codex-rs/core/{prompt_file}"
)

PROMPT_FILES = {
    "gpt-5.2-codex": "gpt-5.2-codex_prompt.md",
    "codex-max": "gpt-5.1-codex-max_prompt.md",
    "codex": "gpt_5_codex_prompt.md",
    "gpt-5.2": "gpt_5_2_prompt.md",
    "gpt-5.1": "gpt_5_1_prompt.md",
}


def _http_get(url: str) -> Tuple[int, str, str]:
    req = urllib.request.Request(
        url,
        headers={
            "User-Agent": "koder-codex-prompt-generator",
            "Accept": "application/json, text/plain;q=0.9, */*;q=0.8",
        },
    )
    with urllib.request.urlopen(req, timeout=30) as response:
        status = response.status
        final_url = response.geturl()
        body = response.read().decode("utf-8", errors="replace")
    return status, body, final_url


def _get_latest_tag() -> str:
    try:
        status, body, _ = _http_get(CODEX_GITHUB_API_RELEASES)
        if 200 <= status < 300:
            data = json.loads(body)
            tag = data.get("tag_name")
            if tag:
                return tag
    except Exception:
        pass

    status, body, final_url = _http_get(CODEX_GITHUB_HTML_RELEASES)
    if not (200 <= status < 300):
        raise RuntimeError(f"Failed to fetch latest release page: {status}")

    if "/tag/" in final_url:
        tag = final_url.split("/tag/")[-1]
        if tag and "/" not in tag:
            return tag

    match = re.search(r"/openai/codex/releases/tag/([^\"/]+)", body)
    if match:
        return match.group(1)

    raise RuntimeError("Failed to determine latest release tag from GitHub")


def _fetch_prompts(tag: str) -> Dict[str, str]:
    prompts: Dict[str, str] = {}
    for model_family, prompt_file in PROMPT_FILES.items():
        url = RAW_URL_TEMPLATE.format(tag=tag, prompt_file=prompt_file)
        try:
            status, body, _ = _http_get(url)
        except urllib.error.HTTPError as err:
            raise RuntimeError(f"Failed to fetch {url}: {err.code}") from err
        except urllib.error.URLError as err:
            raise RuntimeError(f"Failed to fetch {url}: {err.reason}") from err

        if not (200 <= status < 300):
            raise RuntimeError(f"Failed to fetch {url}: {status}")
        if not body.strip():
            raise RuntimeError(f"Empty prompt file for {model_family}: {url}")
        prompts[model_family] = body
    return prompts


def _render_python(tag: str, prompts: Dict[str, str]) -> str:
    generated_at = datetime.now(timezone.utc).isoformat()

    lines = [
        "# Generated by scripts/generate_codex_prompts.py. DO NOT EDIT.",
        "# Source: https://raw.githubusercontent.com/openai/codex/{tag}/codex-rs/core/".format(
            tag=tag
        ),
        "",
        "from __future__ import annotations",
        "",
        f"CODEX_PROMPTS_TAG = {json.dumps(tag)}",
        f"CODEX_PROMPTS_GENERATED_AT = {json.dumps(generated_at)}",
        "",
        "CODEX_PROMPTS = {",
    ]

    for key in sorted(prompts.keys()):
        value_literal = json.dumps(prompts[key], ensure_ascii=True)
        lines.append(f"    {json.dumps(key)}: {value_literal},")

    lines.extend(
        [
            "}",
            "",
            "__all__ = [",
            '    "CODEX_PROMPTS",',
            '    "CODEX_PROMPTS_TAG",',
            '    "CODEX_PROMPTS_GENERATED_AT",',
            "]",
            "",
        ]
    )

    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate bundled Codex prompt module.")
    parser.add_argument(
        "--tag",
        help="Codex release tag to fetch (default: latest release).",
    )
    default_output = (
        Path(__file__).resolve().parents[1]
        / "koder_agent"
        / "auth"
        / "codex_prompts.py"
    )
    parser.add_argument(
        "--output",
        default=str(default_output),
        help="Output python module path.",
    )
    args = parser.parse_args()

    tag = args.tag or _get_latest_tag()
    prompts = _fetch_prompts(tag)
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(_render_python(tag, prompts), encoding="utf-8")
    print(f"Generated {output_path} from tag {tag}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
